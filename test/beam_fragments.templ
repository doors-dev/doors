package test

import (
	"context"
	"fmt"
	"github.com/doors-dev/doors"
)

type state struct {
	Int int
	Str string
}

type BeamConsistentFragment struct {
	r *reporter
	b doors.SourceBeam[state]
	n doors.Node
	noBeam
}

templ (f *BeamConsistentFragment) content() {
	{{
	f.b.Sub(ctx, func(ctx context.Context, s state) bool {
		f.r.update(ctx, 0, fmt.Sprint(s.Int))
		return false
	})
	}}
	{{
	n1 := doors.Node{}
	n2 := doors.Node{}
	f.b.Mutate(ctx, func(s *state) bool {
		s.Int = s.Int + 1
		return true
	})
	r, _ := f.b.Read(ctx)
	}}
	@reportId(1, fmt.Sprint(r.Int))
	@n1 {
		{{
	f.b.Mutate(ctx, func(s *state) bool {
		s.Int = s.Int + 1
		return true
	})
	r, _ := f.b.Read(ctx)
		}}
		@reportId(2, fmt.Sprint(r.Int))
	}
	@n2 {
		{{
	f.b.Mutate(ctx, func(s *state) bool {
		s.Int = s.Int + 1
		return true
	})
	r, _ := f.b.Read(ctx)
		}}
		@reportId(3, fmt.Sprint(r.Int))
	}
}

templ (f *BeamConsistentFragment) Render() {
	@f.n {
		@f.content()
	}
	@button("reload", func(ctx context.Context) bool {
		f.n.Update(ctx, f.content())
		return true
	})
	@doors.F(f.r)
}

type BeamUpdateFragment struct {
	r *reporter
	b doors.SourceBeam[state]
	noBeam
}

templ (f *BeamUpdateFragment) Render() {
	{{
	f.b.Sub(ctx, func(ctx context.Context, s state) bool {
		f.r.update(ctx, 0, fmt.Sprint(s.Int))
		return false
	})
	}}
	@button("update", func(ctx context.Context) bool {
		f.b.Update(ctx, state{
			Int: 1,
		})
		return true
	})
	@button("mutate", func(ctx context.Context) bool {
		f.b.Mutate(ctx, func(s *state) bool {
			s.Int = s.Int + 1
			return true
		})
		return true
	})
	@button("mutate-cancel", func(ctx context.Context) bool {
		f.b.Mutate(ctx, func(s *state) bool {
			s.Int = s.Int + 1
			return false
		})
		return true
	})
	@doors.F(f.r)
}
