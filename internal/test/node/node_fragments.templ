package node

import (
	"context"
	"fmt"
	"github.com/doors-dev/doors"
	"github.com/doors-dev/doors/internal/test"
)

type FragmentMany struct {
	n doors.Node
	test.NoBeam
}

templ (f *FragmentMany) sample() {
	<div class="sample">sample</div>
}

templ (f *FragmentMany) manyNodes() {
	for i := range 2 {
        {{ println(i) }}
		<span style="display:none">{ fmt.Sprint(i) }</span>
		@f.n
	}
}

templ (f *FragmentMany) replaced() {
	{{ f.n.Replace(ctx, f.sample()) }}
	for i := range 100 {
		<span style="display:none">{ fmt.Sprint(i) }</span>
		@f.n
	}
}

templ (f *FragmentMany) Render() {
	{{ f.n.Update(ctx, f.sample()) }}
	{{ n := doors.Node{} }}
	@n {
		@f.manyNodes()
	}
	@test.Button("replace", func(ctx context.Context) bool {
		n.Update(ctx, f.replaced())
		return true
	})
}

type FragmentX struct {
	report doors.Node
	n      doors.Node
	test.NoBeam
}

func (f *FragmentX) rep(ctx context.Context, s string) {
	f.report.Update(ctx, test.Report(s))
}

templ (f *FragmentX) Render() {
	@f.n {
		@test.Marker("init")
	}
	@f.report
	<button
		id="updatex"
		{ doors.A(ctx, doors.AClick {
        On: func(ctx context.Context, _ doors.REvent[doors.PointerEvent]) bool {
            ch, ok := f.n.XUpdate(ctx, test.Marker("updated"))
            if !ok {
               f.rep(ctx, "false update")
                return true
            }
            err, ok := <- ch
            if !ok {
                f.rep(ctx, "channel closed")
                return true
            }
            if err != nil {
                f.rep(ctx, "channel err: "+err.Error())
                return true
            } 
            f.rep(ctx, "ok")
            return false
        },

    }) ... }
	>C</button>
	<button
		id="removex"
		{ doors.A(ctx, doors.AClick {
        On: func(ctx context.Context, _ doors.REvent[doors.PointerEvent]) bool {
            ch, ok := f.n.XRemove(ctx)
            if !ok {
                f.rep(ctx, "false remove")
                return true
            }
            err, ok := <- ch
            if !ok {
                f.rep(ctx, "channel closed")
                return true
            }
            if err != nil {
                f.rep(ctx, "channel err: "+err.Error())
                return true
            } 
            f.rep(ctx, "ok")
            return true
        },

    }) ... }
	>R</button>
}

type EmbeddedFragment struct {
	n1 doors.Node
	n2 doors.Node
	n3 doors.Node
	test.NoBeam
}

templ (f *EmbeddedFragment) Render() {
	@f.n1 {
		@f.n2 {
			@test.Marker("init")
		}
	}
	@f.n3
	<button
		id="clear"
		{ doors.A(ctx, doors.AClick {
        On: func(ctx context.Context, _ doors.REvent[doors.PointerEvent]) bool {
            f.n1.Clear(ctx)
            return true
        },

    }) ... }
	>C</button>
	<button
		id="remove"
		{ doors.A(ctx, doors.AClick {
        On: func(ctx context.Context, _ doors.REvent[doors.PointerEvent]) bool {
            f.n2.Remove(ctx)
            return true
        },

    }) ... }
	>C</button>
	<button
		id="replace"
		{ doors.A(ctx, doors.AClick {
        On: func(ctx context.Context, _ doors.REvent[doors.PointerEvent]) bool {
            f.n2.Update(ctx, test.Marker("replaced"))
            f.n3.Update(ctx, test.Marker("temp"))
            f.n3.Replace(ctx, &f.n2)
            return true
        },

    }) ... }
	>C</button>
}

type DynamicFragment struct {
	n1 doors.Node
	n2 doors.Node
	test.NoBeam
}

templ (f *DynamicFragment) Render() {
	{{ f.n1.Update(ctx, test.Marker("init")) }}
	@f.n1
	<button
		id="update"
		{ doors.A(ctx, doors.AClick {
        On: func(ctx context.Context, _ doors.REvent[doors.PointerEvent]) bool {
            f.n1.Update(ctx, test.Marker("updated"))
            return true
        },

    }) ... }
	>
		U
	</button>
	<button
		id="replace"
		{ doors.A(ctx, doors.AClick {
        On: func(ctx context.Context, _ doors.REvent[doors.PointerEvent]) bool {
            f.n2.Update(ctx, test.Marker("replaced"))
            f.n1.Replace(ctx, &f.n2)
            return true
        },

    }) ... }
	>
		Rp
	</button>
	<button
		id="remove"
		{ doors.A(ctx, doors.AClick {
        On: func(ctx context.Context, _ doors.REvent[doors.PointerEvent]) bool {
            f.n2.Remove(ctx)
            return true
        },

    }) ... }
	>
		Remove
	</button>
}

type BeforeFragment struct {
	nodeInit     doors.Node
	nodeUpdate   doors.Node
	nodeRemoved  doors.Node
	nodeReplaced doors.Node
	test.NoBeam
}

templ (f *BeforeFragment) Render() {
	@f.nodeInit {
		@test.Marker("init")
	}
	{{ f.nodeUpdate.Update(ctx, test.Marker("updated")) }}
	@f.nodeUpdate
	{{ f.nodeRemoved.Update(ctx, test.Marker("removed")) }}
	{{ f.nodeRemoved.Remove(ctx) }}
	@f.nodeRemoved
	{{ f.nodeReplaced.Replace(ctx, test.Marker("replaced")) }}
	@f.nodeReplaced {
		@test.Marker("#initReplaced")
	}
}
