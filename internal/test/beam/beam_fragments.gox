package beam

import (
	"context"
	"fmt"
	"time"

	"github.com/doors-dev/doors"
	"github.com/doors-dev/doors/internal/test"
	"github.com/doors-dev/gox"
)

type state struct {
	Int int
	Str string
}

type BeamSkipFragment struct {
	r *test.Reporter
	b doors.Source[state]
	node doors.Door
	test.NoBeam
}

elem (f *BeamSkipFragment) Main() {
	~{
		f.r.Update(ctx, 0, "init")
		f.b.ReadAndSub(ctx, func(ctx context.Context, s state) bool {
			<-time.After(300 * time.Millisecond)
			return false
		})
	}
	~>(f.node)
	<>
		~{
			f.b.Sub(ctx, func(ctx context.Context, s state) bool {
				if s.Str == "1" {
					f.r.Update(ctx, 0, "propagated")
				}
				return false
			})
		}
	</>
	~(test.Button("update1", func(ctx context.Context) bool {
		f.b.Update(ctx, state{Str: "1"})
		return false
	}))
	~(test.Button("update2", func(ctx context.Context) bool {
		f.b.Update(ctx, state{Str: "2"})
		return false
	}))
	~(f.r)
}

type BeamDeriveFragment struct {
	r *test.Reporter
	b doors.Source[state]
	n doors.Door
	test.NoBeam
}

elem (f *BeamDeriveFragment) content() {
	~{
		d := doors.NewBeam(f.b, func(s state) int {
			return s.Int
		})
		f.b.Sub(ctx, func(ctx context.Context, s state) bool {
			f.r.Update(ctx, 0, fmt.Sprint(s.Int))
			return false
		})
		n1 := doors.Door{}
		n2 := doors.Door{}
		f.b.Mutate(ctx, func(s state) state {
			s.Int = s.Int + 1
			return s
		})
		r, _ := d.Read(ctx)
	}
	~(test.ReportId(1, fmt.Sprint(r)))
	~>(n1)
	<>
		~{
			f.b.Mutate(ctx, func(s state) state {
				s.Int = s.Int + 1
				return s
			})
			r, _ := d.Read(ctx)
		}
		~(test.ReportId(2, fmt.Sprint(r)))
		~{
			n3 := doors.Door{}
			d.Sub(ctx, func(ctx context.Context, s int) bool {
				n3.Update(ctx, test.ReportId(4, fmt.Sprint(s)))
				return false
			})
		}
		~(&n3)
	</>
	~>(n2)<>
		~{
			f.b.Mutate(ctx, func(s state) state {
				s.Int = s.Int + 1
				return s
			})
			r, _ := f.b.Read(ctx)
		}
		~(test.ReportId(3, fmt.Sprint(r.Int)))
	</>
	~(f.r)
}

elem (f *BeamDeriveFragment) Main() {
	~>(f.n)
	<>
		~(f.content())
	</>
	~(test.Button("reload", func(ctx context.Context) bool {
		f.n.Update(ctx, f.content())
		return true
	}))
}

type BeamConsistentFragment struct {
	r *test.Reporter
	b doors.Source[state]
	n doors.Door
	test.NoBeam
}

elem (f *BeamConsistentFragment) content() {
	~{
		f.b.Sub(ctx, func(ctx context.Context, s state) bool {
			f.r.Update(ctx, 0, fmt.Sprint(s.Int))
			return false
		})
		n1 := doors.Door{}
		n2 := doors.Door{}
		f.b.Mutate(ctx, func(s state) state {
			s.Int = s.Int + 1
			return s
		})
		r, _ := f.b.Read(ctx)
	}
	~(test.ReportId(1, fmt.Sprint(r.Int)))
	~>(n1)<>
		~{
			f.b.Mutate(ctx, func(s state) state {
				s.Int = s.Int + 1
				return s
			})
			r, _ := f.b.Read(ctx)
		}
		~(test.ReportId(2, fmt.Sprint(r.Int)))
		~{
			n3 := doors.Door{}
			f.b.Sub(ctx, func(ctx context.Context, s state) bool {
				n3.Update(ctx, test.ReportId(4, fmt.Sprint(s.Int)))
				return false
			})
		}
		~(&n3)
	</>
	~>(n2)<>
		~{
			f.b.Mutate(ctx, func(s state) state {
				s.Int = s.Int + 1
				return s
			})
			r, _ := f.b.Read(ctx)
		}
		~(test.ReportId(3, fmt.Sprint(r.Int)))
	</>
	~(f.r)
}

elem (f *BeamConsistentFragment) Main() {
	~>(f.n)<>
		~(f.content())
	</>
	~(test.Button("reload", func(ctx context.Context) bool {
		f.n.Reload(ctx)
		return true
	}))
}

type BeamUpdateFragment struct {
	r *test.Reporter
	b doors.Source[state]
	test.NoBeam
}

elem (f *BeamUpdateFragment) Main() {
	~{
		f.b.Sub(ctx, func(ctx context.Context, s state) bool {
			f.r.Update(ctx, 0, fmt.Sprint(s.Int))
			return false
		})
	}
	~(
		test.Button("update", func(ctx context.Context) bool {
			f.b.Update(ctx, state{
				Int: 1,
			})
			return true
		}),
		test.Button("mutate", func(ctx context.Context) bool {
			f.b.Mutate(ctx, func(s state) state {
				s.Int = s.Int + 1
				return s
			})
			return true
		}),
		test.Button("mutate-cancel", func(ctx context.Context) bool {
			f.b.Mutate(ctx, func(s state) state {
				return s
			})
			return true
		}),
		f.r
	)
}
