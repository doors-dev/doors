package attr

import (
	"context"
	"encoding/json"
	"github.com/doors-dev/doors"
	"github.com/doors-dev/doors/internal/test"
)

type pointerFragment struct {
	test.NoBeam
	r *test.Reporter
}

templ (f *pointerFragment) Render() {
	{{ f.r.Update(ctx, 0, "") }}
	@doors.F(f.r)
	<div
		id="down"
		{ doors.A(ctx, doors.APointerDown {
                        On: func(ctx context.Context, r doors.REvent[doors.PointerEvent]) bool {
                            f.r.Update(ctx, 0, "DOWN")
                         f.r.Update(ctx, 1, test.Float(r.Event().PageX))
                         f.r.Update(ctx, 2, test.Float(r.Event().PageY))
                            return false
                        },
                })... }
	>PointerDown</div>
	<div
		id="up"
		{ doors.A(ctx, doors.APointerUp {
                        On: func(ctx context.Context, r doors.REvent[doors.PointerEvent]) bool {
                            f.r.Update(ctx, 0, "UP")
                         f.r.Update(ctx, 1, test.Float(r.Event().PageX))
                         f.r.Update(ctx, 2, test.Float(r.Event().PageY))
                            return false
                        },
                })... }
	>PointerUp</div>
	<div
		id="enter"
		{ doors.A(ctx, doors.APointerEnter {
                        On: func(ctx context.Context, r doors.REvent[doors.PointerEvent]) bool {
                         f.r.Update(ctx, 0, "ENTER")
                         f.r.Update(ctx, 1, test.Float(r.Event().PageX))
                         f.r.Update(ctx, 2, test.Float(r.Event().PageY))
                            return false
                        },
                })... }
	>PointerEnter</div>
	<div id="beforeLeave">beforeLeave</div>
	<div
		id="leave"
		{ doors.A(ctx, doors.APointerLeave {
                        On: func(ctx context.Context, r doors.REvent[doors.PointerEvent]) bool {
                         f.r.Update(ctx, 0, "LEAVE")
                         f.r.Update(ctx, 1, test.Float(r.Event().PageX))
                         f.r.Update(ctx, 2, test.Float(r.Event().PageY))
                            return false
                        },
                })... }
	>PointerLeave</div>
	<div
		id="move"
		{ doors.A(ctx, doors.APointerMove {
                        On: func(ctx context.Context, r doors.REvent[doors.PointerEvent]) bool {
                         f.r.Update(ctx, 0, "MOVE")
                         f.r.Update(ctx, 1, test.Float(r.Event().PageX))
                         f.r.Update(ctx, 2, test.Float(r.Event().PageY))
                            return false
                        },
                })... }
	>PointerMove</div>
	<div
		id="over"
		{ doors.A(ctx, doors.APointerOver {
                        On: func(ctx context.Context, r doors.REvent[doors.PointerEvent]) bool {
                         f.r.Update(ctx, 0, "OVER")
                         f.r.Update(ctx, 1, test.Float(r.Event().PageX))
                         f.r.Update(ctx, 2, test.Float(r.Event().PageY))
                            return false
                        },
                })... }
	>Over</div>
	<div id="beforeOut">beforeOut</div>
	<div
		id="out"
		{ doors.A(ctx, doors.APointerOut {
                        On: func(ctx context.Context, r doors.REvent[doors.PointerEvent]) bool {
                         f.r.Update(ctx, 0, "OUT")
                         f.r.Update(ctx, 1, test.Float(r.Event().PageX))
                         f.r.Update(ctx, 2, test.Float(r.Event().PageY))
                            return false
                        },
                })... }
	>Out</div>
}

type callFragment struct {
	data string
	test.NoBeam
	r *test.Reporter
}

func (d *callFragment) attr() []doors.Attr {
	return []doors.Attr{doors.AHook[string, int]{
		Name: "myHook",
		On: func(ctx context.Context, r doors.RHook[string]) (int, bool) {
			d.r.Update(ctx, 0, r.Data())
			doors.Call(ctx, doors.CallConf{
				Name: "myCall",
				Arg:  len(r.Data()),
				Trigger: func(ctx context.Context, r doors.RCall) {
					var str string
					decoder := json.NewDecoder(r.Body())
					err := decoder.Decode(&str)
					if err != nil {
						d.r.Update(ctx, 1, err.Error())
						return
					}
					d.r.Update(ctx, 1, str)
				},
			})
			return len(r.Data()), true
		},
	}, doors.AData{
		Name:  "myData",
		Value: d.data,
	}}
}

templ (f *callFragment) Render() {
	@doors.F(f.r)
	<div id="target"></div>
	@doors.Script(f.attr()...) {
		<script>
            $d.on("myCall", (data) => {
                document.getElementById("target").innerHTML = `${data}`
                return "response"
            })
            await $d.hook("myHook", $d.data("myData"))
        </script>
	}
}

type hookFragment struct {
	data string
	test.NoBeam
	r *test.Reporter
}

func (d *hookFragment) attr(ctx context.Context) templ.Attributes {
	return doors.A(ctx, doors.AHook[string, int]{
		Name: "myHook",
		On: func(ctx context.Context, r doors.RHook[string]) (int, bool) {
			d.r.Update(ctx, 0, r.Data())
			return len(r.Data()), true
		},
	}, doors.AData{
		Name:  "myData",
		Value: d.data,
	})
}

templ (f *hookFragment) Render() {
	@doors.F(f.r)
	<div id="target"></div>
	@doors.Script() {
		<script { f.attr(ctx)... }>
        const a = await $d.hook("myHook", $d.data("myData"))
        document.getElementById("target").innerHTML = `${a}`
        </script>
	}
}

type dataFragment struct {
	data string
	test.NoBeam
}

func (d *dataFragment) attr(ctx context.Context) templ.Attributes {
	return doors.A(ctx, doors.AData{
		Name:  "myData",
		Value: d.data,
	})
}

templ (f *dataFragment) Render() {
	<div id="target"></div>
	@doors.Script() {
		<script { f.attr(ctx)... }>
        document.getElementById("target").innerHTML = $d.data("myData")
        </script>
	}
}
