// Generated by GoX

package attr

import (
	"context"
	"fmt"
	"sync/atomic"
	"time"
	
	"github.com/doors-dev/doors"
	"github.com/doors-dev/doors/internal/test"
	"github.com/doors-dev/gox"
)

type scopeFragment struct {
	r *test.Reporter
	test.NoBeam
	counter atomic.Int32
}

func (f *scopeFragment) update(ctx context.Context, marker string) {
	i := f.counter.Add(1)
	f.r.Update(ctx, 0, fmt.Sprint(i - 1))
	f.r.Update(ctx, 1, marker)
}

func (f *scopeFragment) scopePipeline() gox.Elem {
	return gox.Elem(func(__c gox.Cursor) (__e error) {
		ctx := __c.Context(); __c.Noop(ctx)
		ds := &doors.ScopeDebounce{}
		ds2 := &doors.ScopeDebounce{}
		ss := &doors.ScopeSerial{}
		fs := &doors.ScopeFrame{}

		__e = __c.Any(f.button("p1", []doors.Scope{ds.Scope(100 * time.Millisecond, 0)}, "1", false)); if __e != nil { return }
		__e = __c.Any(f.button("p2", []doors.Scope{fs.Scope(false), ds.Scope(100 * time.Millisecond, 0), ss}, "2", true)); if __e != nil { return }
		__e = __c.Any(f.button("p3", []doors.Scope{fs.Scope(false), ds2.Scope(100 * time.Millisecond, 0), ss}, "3", true)); if __e != nil { return }
		__e = __c.Any(f.button("p4", []doors.Scope{fs.Scope(false), ds2.Scope(100 * time.Millisecond, 0), ss}, "4", false)); if __e != nil { return }
		__e = __c.Any(f.button("p5", []doors.Scope{fs.Scope(true)}, "5", true)); if __e != nil { return }
	return })
}

func (f *scopeFragment) Main() gox.Elem {
	return gox.Elem(func(__c gox.Cursor) (__e error) {
		ctx := __c.Context(); __c.Noop(ctx)
		f.update(ctx, "0")

		__e = __c.Any(f.r); if __e != nil { return }
		blocking := doors.ScopeOnlyBlocking()

		__e = __c.Any(f.button("b1", blocking, "1", true)); if __e != nil { return }
		__e = __c.Any(f.button("b2", blocking, "2", true)); if __e != nil { return }
		__e = __c.Any(f.button("b3", blocking, "3", true)); if __e != nil { return }
		serial := doors.ScopeOnlySerial()

		__e = __c.Any(f.button("s1", serial, "1", true)); if __e != nil { return }
		__e = __c.Any(f.button("s2", serial, "2", true)); if __e != nil { return }
		__e = __c.Any(f.button("s3", serial, "3", true)); if __e != nil { return }
		debouce := doors.ScopeOnlyDebounce(300 * time.Millisecond, 0)

		__e = __c.Any(f.button("d1", debouce, "1", false)); if __e != nil { return }
		__e = __c.Any(f.button("d2", debouce, "2", false)); if __e != nil { return }
		__e = __c.Any(f.button("d3", debouce, "3", false)); if __e != nil { return }
		debouce = doors.ScopeOnlyDebounce(300 * time.Millisecond, 700 * time.Millisecond)

		__e = __c.Any(f.button("dl1", debouce, "1", false)); if __e != nil { return }
		__e = __c.Any(f.button("dl2", debouce, "2", false)); if __e != nil { return }
		__e = __c.Any(f.button("dl3", debouce, "3", false)); if __e != nil { return }
		frame := doors.ScopeFrame{}

		__e = __c.Any(f.button("f1", []doors.Scope{frame.Scope(false)}, "1", true)); if __e != nil { return }
		__e = __c.Any(f.button("f2", []doors.Scope{frame.Scope(false)}, "2", false)); if __e != nil { return }
		__e = __c.Any(f.button("f3", []doors.Scope{frame.Scope(true)}, "3", true)); if __e != nil { return }
		__e = __c.Any(f.button("f4", []doors.Scope{frame.Scope(true)}, "4", false)); if __e != nil { return }
		__e = __c.Any(f.scopePipeline()); if __e != nil { return }
	return })
}

func (f *scopeFragment) button(id string, scope []doors.Scope, marker string, delay bool) gox.Elem {
	return gox.Elem(func(__c gox.Cursor) (__e error) {
		ctx := __c.Context(); __c.Noop(ctx)
		__e = __c.Init("button"); if __e != nil { return }
		{
			__e = __c.AttrSetAny("id", id); if __e != nil { return }
			__e = __c.AttrMod(doors.A(ctx, f.handler(scope, marker, delay))); if __e != nil { return }
			__e = __c.Submit(); if __e != nil { return }
			__e = __c.Any(id); if __e != nil { return }
		}
		__e = __c.Close(); if __e != nil { return }
	return })
}

func (f *scopeFragment) handler(scope []doors.Scope, marker string, delay bool) doors.Attr {
	return doors.AClick{
		Scope: scope,
		On: func(ctx context.Context, r doors.REvent[doors.PointerEvent]) bool {
			if delay {
				<-time.After(300 * time.Millisecond)
			}
			f.update(ctx, marker)
			return false
		},
	}
}