package attr

import (
	"context"
	"github.com/doors-dev/doors"
	"github.com/doors-dev/doors/internal/test"
	"net/http"
	"time"
)

type errorFragment struct {
	test.NoBeam
	n1 doors.Node
	n2 doors.Node
}

templ (f *errorFragment) Render() {
	<div id="report">initial</div>
	@doors.Script() {
		<script>
            const r = document.getElementById("report")
            $d.on("root", (e) => {
                    console.log(e)
                r.innerHTML = "root/"+e.meta
            })
            $d.on("error", (e) => {
                    console.log(e)
                r.innerHTML = "root_error/"+e.meta
            })
        </script>
	}
	@f.button("err_1", doors.OnErrorCall("error", "err_1"))
	@f.button("err_2", doors.OnErrorCall("root", "err_2"))
	@f.n1 {
		@doors.Script() {
			<script>
                const r = document.getElementById("report")
                $d.on("n1", (e) => {
                    console.log(e)
                    r.innerHTML = "n1/"+e.meta
                })
                $d.on("error", (e) => {
                    console.log(e)
                    r.innerHTML = "n1_error/"+e.meta
                })
            </script>
		}
		@f.n2 {
			@doors.Script() {
				<script>
                    const r = document.getElementById("report")
                    $d.on("n2", (e) => {
                    console.log(e)
                        r.innerHTML = "n2/"+e.meta
                    })
                </script>
			}
			<div id="indicator">init</div>
			@f.button("err_5", []doors.OnError{doors.CallOnError{
				Name: "n2",
				Meta: "err_5",
			}, doors.IndicateOnError{
				Duration: 500 * time.Millisecond,
				Indicator: []doors.Indicator{
					doors.AttrIndicator{
						Selector: doors.SelectorQuery("#indicator"),
						Name:     "data-indicator",
						Value:    "true",
					},
					doors.ContentIndicator{
						Selector: doors.SelectorQuery("#indicator"),
						Content:  "indicator",
					},
				},
			}})
			@f.button("err_6", doors.OnErrorCall("error", "err_6"))
		}
		@f.button("err_3", doors.OnErrorCall("error", "err_3"))
		@f.button("err_4", doors.OnErrorCall("n1", "err_4"))
	}
}

templ (f *errorFragment) button(id string, on []doors.OnError) {
	<button id={ id } { doors.A(ctx, f.handler(on))... }>
		{ id }
	</button>
}

func (f *errorFragment) handler(on []doors.OnError) doors.Attr {
	return doors.AClick{
		OnError: on,
		On: func(ctx context.Context, r doors.REvent[doors.PointerEvent]) bool {
			w := r.(R)
			w.W().WriteHeader(http.StatusBadGateway)
			return false
		},
	}
}

type R interface {
	W() http.ResponseWriter
}
