package attr

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	
	"github.com/doors-dev/doors"
	"github.com/doors-dev/doors/internal/test"
	"github.com/doors-dev/gox"
)

type pointerFragment struct {
	test.NoBeam
	r *test.Reporter
}

elem (f *pointerFragment) Main() {
	~{
		f.r.Update(ctx, 0, "")
	}
	~(f.r)
	~>doors.APointerDown{
		On: func(ctx context.Context, r doors.REvent[doors.PointerEvent]) bool {
			f.r.Update(ctx, 0, "DOWN")
			f.r.Update(ctx, 1, test.Float(r.Event().PageX))
			f.r.Update(ctx, 2, test.Float(r.Event().PageY))
			return false
		},
	} <div
		id="down">
		PointerDown
	</div>
	~>doors.APointerUp{
		On: func(ctx context.Context, r doors.REvent[doors.PointerEvent]) bool {
			f.r.Update(ctx, 0, "UP")
			f.r.Update(ctx, 1, test.Float(r.Event().PageX))
			f.r.Update(ctx, 2, test.Float(r.Event().PageY))
			return false
		},
	}
	<div
		id="up">
		PointerUp
	</div>
	~>doors.APointerEnter{
		On: func(ctx context.Context, r doors.REvent[doors.PointerEvent]) bool {
			f.r.Update(ctx, 0, "ENTER")
			f.r.Update(ctx, 1, test.Float(r.Event().PageX))
			f.r.Update(ctx, 2, test.Float(r.Event().PageY))
			return false
		},
	} <div
		id="enter">
		PointerEnter
	</div>
	<div id="beforeLeave">beforeLeave</div>
	~>doors.APointerLeave{
		On: func(ctx context.Context, r doors.REvent[doors.PointerEvent]) bool {
			f.r.Update(ctx, 0, "LEAVE")
			f.r.Update(ctx, 1, test.Float(r.Event().PageX))
			f.r.Update(ctx, 2, test.Float(r.Event().PageY))
			return false
		},
	} <div
		id="leave">
		PointerLeave
	</div>
	~>doors.APointerMove{
		On: func(ctx context.Context, r doors.REvent[doors.PointerEvent]) bool {
			f.r.Update(ctx, 0, "MOVE")
			f.r.Update(ctx, 1, test.Float(r.Event().PageX))
			f.r.Update(ctx, 2, test.Float(r.Event().PageY))
			return false
		},
	} <div
		id="move">
		PointerMove
	</div>
	~>doors.APointerOver{
		On: func(ctx context.Context, r doors.REvent[doors.PointerEvent]) bool {
			f.r.Update(ctx, 0, "OVER")
			f.r.Update(ctx, 1, test.Float(r.Event().PageX))
			f.r.Update(ctx, 2, test.Float(r.Event().PageY))
			return false
		},
	} <div
		id="over">
		Over
	</div>
	<div id="beforeOut">beforeOut</div>
	~>doors.APointerOut{
		On: func(ctx context.Context, r doors.REvent[doors.PointerEvent]) bool {
			f.r.Update(ctx, 0, "OUT")
			f.r.Update(ctx, 1, test.Float(r.Event().PageX))
			f.r.Update(ctx, 2, test.Float(r.Event().PageY))
			return false
		},
	} <div
		id="out">
		Out
	</div>
}

type callFragment struct {
	data string
	test.NoBeam
	r *test.Reporter
}

elem (f *callFragment) Main() {
	~(f.r)
	<div id="target"></div>
	~>doors.AHook[string]{
		Name: "myHook",
		On: func(ctx context.Context, r doors.RHook[string]) (any, bool) {
			f.r.Update(ctx, 0, r.Data())
			ch, _ := doors.XCall[string](ctx, doors.ActionEmit{Name: "myCall", Arg: len(r.Data())})
			res := <-ch
			f.r.Update(ctx, 1, res.Ok)
			return len(r.Data()), true
		},
	} ~>doors.AData{
		Name: "myData",
		Value: f.data,
	} <script>
		$on("myCall", (data) => {
			document.getElementById("target").innerHTML = `${data}`
			return "response"
		})
		await $hook("myHook", $data("myData"))
	</script>
}

type hookFragment struct {
	data string
	test.NoBeam
	r *test.Reporter
}

func (d *hookFragment) attr() []doors.Attr {
	return []doors.Attr{
		doors.AHook[string]{
			Name: "myHook",
			On: func(ctx context.Context, r doors.RHook[string]) (any, bool) {
				d.r.Update(ctx, 0, r.Data())
				return len(r.Data()), true
			},
		},
		doors.ARawHook{
			Name: "rawHook",
			On: func(ctx context.Context, r doors.RRawHook) bool {
				body, err := io.ReadAll(r.Body())
				if err != nil {
					return true
				}
				var str string
				json.Unmarshal(body, &str)
				d.r.Update(ctx, 1, str)
				fmt.Fprint(r.W(), len(str))
				return true
			},
		},
		doors.AData{
			Name: "myData",
			Value: d.data,
		},
	}
}

elem (f *hookFragment) Main() {
	~(f.r)
	<div id="target"></div>
	<div id="target2"></div>
	~>(doors.A(ctx, f.attr()...)) <script>
		const a = await $hook("myHook", $data("myData"))
		document.getElementById("target").innerHTML = `${a}`
		const b = await $hook("rawHook", $data("myData"))
		document.getElementById("target2").innerHTML = `${b}`
	</script>
}

type dataFragment struct {
	data string
	test.NoBeam
}

elem (f *dataFragment) Main() {
	<div id="target"></div>
	~>doors.AData{
		Name: "myData",
		Value: f.data,
	} <script>
		document.getElementById("target").innerHTML = $data("myData")
	</script>
}
