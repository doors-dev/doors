package attr

import "github.com/doors-dev/doors"

import "github.com/doors-dev/doors/internal/test"

import "sync/atomic"

import "context"
import "fmt"

import "time"

type scopeFragment struct {
	r *test.Reporter
	test.NoBeam
	counter atomic.Int32
}

func (f *scopeFragment) update(ctx context.Context, marker string) {
	i := f.counter.Add(1)
	f.r.Update(ctx, 0, fmt.Sprint(i-1))
	f.r.Update(ctx, 1, marker)
}

templ (f *scopeFragment) scopePipeline() {
	{{
	ds := &doors.ScopeDebounce{}
	ds2 := &doors.ScopeDebounce{}
	ss := &doors.ScopeSerial{}
	fs := &doors.ScopeFrame{}
	}}
	@f.button("p1", []doors.Scope{ds.Scope(100*time.Millisecond, 0)}, "1", false)
	@f.button("p2", []doors.Scope{fs.Scope(false), ds.Scope(100*time.Millisecond, 0), ss}, "2", true)
	@f.button("p3", []doors.Scope{fs.Scope(false), ds2.Scope(100*time.Millisecond, 0), ss}, "3", true)
	@f.button("p4", []doors.Scope{fs.Scope(false), ds2.Scope(100*time.Millisecond, 0), ss}, "4", false)
	@f.button("p5", []doors.Scope{fs.Scope(true)}, "5", true)
}

templ (f *scopeFragment) Render() {
	{{ f.update(ctx, "0") }}
	@f.r.Render()
	{{ blocking := doors.ScopeOnlyBlocking() }}
	@f.button("b1", blocking, "1", true)
	@f.button("b2", blocking, "2", true)
	@f.button("b3", blocking, "3", true)
	// serial
	{{ serial := doors.ScopeOnlySerial() }}
	@f.button("s1", serial, "1", true)
	@f.button("s2", serial, "2", true)
	@f.button("s3", serial, "3", true)
	// debounce
	{{ debouce := doors.ScopeOnlyDebounce(300*time.Millisecond, 0) }}
	@f.button("d1", debouce, "1", false)
	@f.button("d2", debouce, "2", false)
	@f.button("d3", debouce, "3", false)
	// debounce with limit
	{{ debouce = doors.ScopeOnlyDebounce(300*time.Millisecond, 700*time.Millisecond) }}
	@f.button("dl1", debouce, "1", false)
	@f.button("dl2", debouce, "2", false)
	@f.button("dl3", debouce, "3", false)
	// frame
	{{ frame := doors.ScopeFrame{} }}
	@f.button("f1", []doors.Scope{frame.Scope(false)}, "1", true)
	@f.button("f2", []doors.Scope{frame.Scope(false)}, "2", false)
	@f.button("f3", []doors.Scope{frame.Scope(true)}, "3", true)
	@f.button("f4", []doors.Scope{frame.Scope(true)}, "4", false)
	@f.scopePipeline()
}

templ (f *scopeFragment) button(id string, scope []doors.Scope, marker string, delay bool) {
	<button id={ id } { doors.A(ctx, f.handler(scope, marker, delay))... }>{ id }</button>
}

func (f *scopeFragment) handler(scope []doors.Scope, marker string, delay bool) doors.Attr {
	return doors.AClick{
		Scope: scope,
		On: func(ctx context.Context, r doors.REvent[doors.PointerEvent]) bool {
			if delay {
				<-time.After(300 * time.Millisecond)
			}
			f.update(ctx, marker)
			return false
		},
	}
}
